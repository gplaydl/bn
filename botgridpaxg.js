// botpaxg-grid.js
'use strict';

const express = require('express');
const axios = require('axios').default;
const crypto = require('crypto');

const app = express();
app.use(express.json());

// ====== C·∫•u h√¨nh ng∆∞·ªùi d√πng ======
const SYMBOL          = process.env.SYMBOL || 'PAXGUSDT';
const QUOTE           = process.env.QUOTE  || 'USDT';
const BASE            = process.env.BASE   || 'PAXG';

const BUY_AMOUNT_USD  = Number(process.env.BUY_AMOUNT_USD || 40);
const INTERVAL        = Number(process.env.INTERVAL_MS || 30_000);
const KEEPALIVE_URL   = process.env.KEEPALIVE_URL || 'https://bn-5l7b.onrender.com/health';

// Grid config: ∆∞u ti√™n GRID_MIN/MAX/NODES; n·∫øu thi·∫øu th√¨ d√πng GRID_STEP_USD = 10
const GRID_MIN        = process.env.GRID_MIN ? Number(process.env.GRID_MIN) : null;
const GRID_MAX        = process.env.GRID_MAX ? Number(process.env.GRID_MAX) : null;
const GRID_NODES      = process.env.GRID_NODES ? Number(process.env.GRID_NODES) : null;
const GRID_STEP_USD   = Number(process.env.GRID_STEP_USD || 10);

// ====== Telegram Bot ======
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const TELEGRAM_CHAT_ID   = process.env.TELEGRAM_CHAT_ID;
if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) {
  console.warn('‚ö†Ô∏è Thi·∫øu TELEGRAM_BOT_TOKEN ho·∫∑c TELEGRAM_CHAT_ID, s·∫Ω kh√¥ng g·ª≠i Telegram');
}
async function sendTelegramMessage(text) {
  console.log(text);
  if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) return;
  try {
    await axios.post(
      `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`,
      { chat_id: TELEGRAM_CHAT_ID, text, parse_mode: 'Markdown' }
    );
  } catch (e) {
    console.error('üö® L·ªói g·ª≠i Telegram:', e.response?.data || e.message);
  }
}

// ====== API Binance ======
const API_KEY    = process.env.BINANCE_API_KEY;
const API_SECRET = process.env.BINANCE_API_SECRET;
if (!API_KEY || !API_SECRET) {
  console.error('‚ùå Thi·∫øu BINANCE_API_KEY ho·∫∑c BINANCE_API_SECRET');
  process.exit(1);
}
const BINANCE = axios.create({
  baseURL: 'https://api.binance.com',
  timeout: 15_000,
  headers: { 'X-MBX-APIKEY': API_KEY }
});

// ====== Retry helper ======
async function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
async function retry(fn, { retries = 3, delay = 500, backoff = 2 } = {}) {
  let attempt = 0, lastErr;
  while (attempt < retries) {
    try { return await fn(); }
    catch (err) {
      lastErr = err;
      attempt++;
      if (attempt >= retries) break;
      const d = delay * Math.pow(backoff, attempt - 1);
      await wait(d);
    }
  }
  throw lastErr;
}

// ====== Signing & basic helpers ======
function signQuery(paramsObj) {
  const qs = new URLSearchParams(paramsObj).toString();
  const signature = crypto.createHmac('sha256', API_SECRET).update(qs).digest('hex');
  return `${qs}&signature=${signature}`;
}
async function binanceGET(path, params = {}) {
  return await retry(async () => {
    const query = signQuery({ ...params, timestamp: Date.now(), recvWindow: 5000 });
    const { data } = await BINANCE.get(`${path}?${query}`);
    return data;
  });
}
async function binancePOST(path, params = {}) {
  return await retry(async () => {
    const query = signQuery({ ...params, timestamp: Date.now(), recvWindow: 5000 });
    const { data } = await BINANCE.post(`${path}?${query}`);
    return data;
  });
}

// ====== Filters & Helpers ======
let filters = {
  tickSize: 0, stepSize: 0, minNotional: 0, minQty: 0,
  minPrice: 0, maxPrice: Infinity, maxQty: Infinity
};

function toNumber(x) { return typeof x==='number' ? x : Number(x); }
function decimalPlaces(s) { return String(s).includes('.') ? String(s).split('.')[1].replace(/0+$/,'').length : 0; }
function floorToStep(v, step) { v=toNumber(v); step=toNumber(step); return step===0?v:Math.floor(v/step)*step; }
function roundToTick(v, tick) { v=toNumber(v); tick=toNumber(tick); return tick===0?v:Math.floor(v/tick)*tick; }
function ceilToTick(v, tick)  { v=toNumber(v); tick=toNumber(tick); return tick===0?v:Math.ceil(v/tick)*tick; }
function formatByTick(v, tick){ return toNumber(v).toFixed(Math.max(decimalPlaces(tick),0)); }
function formatByStep(v, step){ return toNumber(v).toFixed(Math.max(decimalPlaces(step),0)); }
function ensureNotional(p, q, minN){ return toNumber(p)*toNumber(q) >= toNumber(minN); }

// ====== Load symbol filters ======
async function loadSymbolFilters() {
  const { data } = await BINANCE.get('/api/v3/exchangeInfo', { params:{symbol:SYMBOL} });
  const sym = data.symbols?.[0]; if (!sym) throw new Error('Kh√¥ng t√¨m th·∫•y symbol');
  const pf = sym.filters.find(f=>f.filterType==='PRICE_FILTER');
  const ls = sym.filters.find(f=>f.filterType==='LOT_SIZE');
  const mn = sym.filters.find(f=>f.filterType==='MIN_NOTIONAL')||sym.filters.find(f=>f.filterType==='NOTIONAL');
  filters.tickSize    = toNumber(pf?.tickSize||0);
  filters.minPrice    = toNumber(pf?.minPrice||0);
  filters.maxPrice    = toNumber(pf?.maxPrice||Infinity);
  filters.stepSize    = toNumber(ls?.stepSize||0);
  filters.minQty      = toNumber(ls?.minQty||0);
  filters.maxQty      = toNumber(ls?.maxQty||Infinity);
  filters.minNotional = toNumber(mn?.minNotional||mn?.notional||0);
}

// ====== Binance helper APIs (gom request m·ªói v√≤ng) ======
async function getBalances() {
  const acc = await binanceGET('/api/v3/account');
  const findFree = a => toNumber(acc.balances.find(b=>b.asset===a)?.free||0);
  return { usdtFree:findFree(QUOTE), baseFree:findFree(BASE) };
}
async function getCurrentPrice() {
  const { data } = await BINANCE.get('/api/v3/ticker/price',{params:{symbol:SYMBOL}});
  return toNumber(data.price);
}
async function getOpenOrders() {
  return await binanceGET('/api/v3/openOrders',{ symbol:SYMBOL });
}
async function getOrder(orderId) {
  return await binanceGET('/api/v3/order',{ symbol:SYMBOL, orderId });
}
async function placeLimit(side, price, qty) {
  const pAdj = formatByTick(price, filters.tickSize);
  const qAdj = formatByStep(qty,    filters.stepSize);
  if (toNumber(pAdj)<filters.minPrice||toNumber(pAdj)>filters.maxPrice)
    throw new Error(`Gi√° ${pAdj} ngo√†i [${filters.minPrice},${filters.maxPrice}]`);
  if (toNumber(qAdj)<filters.minQty||toNumber(qAdj)>filters.maxQty)
    throw new Error(`Qty ${qAdj} ngo√†i [${filters.minQty},${filters.maxQty}]`);
  if (!ensureNotional(pAdj,qAdj,filters.minNotional))
    throw new Error(`Notional ${(pAdj*qAdj)} < ${filters.minNotional}`);
  return await binancePOST('/api/v3/order', {
    symbol:SYMBOL, side, type:'LIMIT', timeInForce:'GTC',
    price:pAdj, quantity:qAdj, newOrderRespType:'RESULT'
  });
}

// ====== Grid state ======
// Tr·∫°ng th√°i t·ªëi gi·∫£n theo n·ªët hi·ªán t·∫°i (m·ªôt workflow t·∫°i m·ªôt th·ªùi ƒëi·ªÉm)
let grid = {
  min: null,
  max: null,
  nodes: null,        // s·ªë n·ªët (intervals)
  levels: [],         // danh s√°ch m·ªëc gi√° [p0, p1, ..., pn]
};

let state = {
  currentNode: null,      // index interval i: [levels[i], levels[i+1]]
  mode: 'IDLE',           // 'IDLE' | 'BUY_PLACED' | 'HOLDING' | 'SELL_PLACED'
  buyOrderId: null,
  sellOrderId: null,
  lastBuyQty: 0,
  lastBuyAvg: null
};

// Kh·ªüi t·∫°o grid: ∆∞u ti√™n GRID_MIN/MAX/NODES; n·∫øu thi·∫øu s·∫Ω t·∫°o grid ƒë·ªông theo GRID_STEP_USD quanh gi√° hi·ªán t·∫°i
async function ensureGrid(price) {
  if (grid.levels.length) return;

  if (GRID_MIN != null && GRID_MAX != null && GRID_NODES != null && GRID_MAX > GRID_MIN && GRID_NODES > 0) {
    grid.min   = GRID_MIN;
    grid.max   = GRID_MAX;
    grid.nodes = GRID_NODES;
  } else {
    // grid ƒë·ªông: t·∫°o 40 b·∫≠c (~20 d∆∞·ªõi, 20 tr√™n) v·ªõi step = GRID_STEP_USD
    const stepsEachSide = 20;
    const low  = Math.max(filters.minPrice, price - stepsEachSide * GRID_STEP_USD);
    const high = Math.min(filters.maxPrice, price + stepsEachSide * GRID_STEP_USD);
    grid.min   = roundToTick(low,  filters.tickSize);
    grid.max   = roundToTick(high, filters.tickSize);
    grid.nodes = Math.max(1, Math.floor((grid.max - grid.min) / GRID_STEP_USD));
  }

  // T·∫°o levels
  const width = (grid.max - grid.min) / grid.nodes;
  grid.levels = Array.from({length: grid.nodes + 1}, (_, i) => formatByTick(grid.min + i * width, filters.tickSize)).map(Number);

  await sendTelegramMessage(
    `üß± Kh·ªüi t·∫°o Grid\n` +
    `‚Ä¢ Min: ${grid.min}\n` +
    `‚Ä¢ Max: ${grid.max}\n` +
    `‚Ä¢ N·ªët: ${grid.nodes}\n` +
    `‚Ä¢ B∆∞·ªõc ~: ${((grid.max-grid.min)/grid.nodes).toFixed(4)}`
  );
}

function findNodeIndex(price) {
  const lv = grid.levels;
  if (!lv.length) return null;
  if (price < lv[0] || price > lv[lv.length-1]) return null;
  // t√¨m i sao cho price thu·ªôc [lv[i], lv[i+1]]
  for (let i = 0; i < lv.length - 1; i++) {
    if (price >= lv[i] && price <= lv[i+1]) return i;
  }
  return null;
}

// ====== Main cycle ======
async function mainCycle() {
  try {
    if (!filters.tickSize) await loadSymbolFilters();

    // Gom API: gi√°, s·ªë d∆∞, openOrders
    const [price, balances, openOrders] = await Promise.all([
      retry(() => getCurrentPrice(), {retries: 3, delay: 400}),
      retry(() => getBalances(),     {retries: 3, delay: 400}),
      retry(() => getOpenOrders(),   {retries: 3, delay: 400}),
    ]);

    await ensureGrid(price);

    // X√°c ƒë·ªãnh n·ªët hi·ªán t·∫°i
    const idx = findNodeIndex(price);
    if (idx === null) {
      // Gi√° ngo√†i grid
      await sendTelegramMessage(
        `üìõ ${SYMBOL}\n` +
        `‚Ä¢ Gi√° hi·ªán t·∫°i: ${price}\n` +
        `‚Ä¢ Tr·∫°ng th√°i: Ngo√†i d·∫£i Grid [${grid.min}, ${grid.max}]`
      );
      return;
    }

    state.currentNode = idx;
    const nodeMin = grid.levels[idx];
    const nodeMax = grid.levels[idx + 1];

    // ƒê·ªìng b·ªô tr·∫°ng th√°i d·ª±a v√†o l·ªánh m·ªü hi·ªán c√≥ (ƒë·ªÉ tr√°nh tr√πng l·ªánh)
    const buyPending  = openOrders.find(o => o.side==='BUY'  && Number(o.price)===Number(formatByTick(nodeMin, filters.tickSize)));
    const sellPending = openOrders.find(o => o.side==='SELL' && Number(o.price)===Number(formatByTick(nodeMax, filters.tickSize)));

    if (buyPending) {
      state.mode = 'BUY_PLACED';
      state.buyOrderId = buyPending.orderId;
    } else if (sellPending) {
      state.mode = 'SELL_PLACED';
      state.sellOrderId = sellPending.orderId;
    } else if (state.mode === 'BUY_PLACED' || state.mode === 'SELL_PLACED') {
      // Kh√¥ng c√≤n l·ªánh pending -> chuy·ªÉn sang IDLE n·∫øu ch∆∞a gi·ªØ h√†ng
      if (state.mode === 'SELL_PLACED') {
        // c√≥ th·ªÉ v·ª´a kh·ªõp SELL -> v·ªÅ IDLE
        state.mode = 'IDLE';
        state.lastBuyQty = 0;
        state.lastBuyAvg = null;
      } else {
        state.mode = 'IDLE';
      }
      state.buyOrderId = null;
      state.sellOrderId = null;
    }

    // H√†nh vi theo mode
    if (state.mode === 'IDLE') {
      // Ch∆∞a mua -> ki·ªÉm tra USDT v√† ƒë·∫∑t BUY t·∫°i min n·ªët
      if (balances.usdtFree <= BUY_AMOUNT_USD) {
        await sendTelegramMessage(
          `‚ÑπÔ∏è ${SYMBOL}\n` +
          `‚Ä¢ Gi√°: ${price}\n` +
          `‚Ä¢ N·ªët: [${nodeMin}, ${nodeMax}]\n` +
          `‚Ä¢ USDT (${balances.usdtFree}) kh√¥ng ƒë·ªß > ${BUY_AMOUNT_USD} ƒë·ªÉ ƒë·∫∑t BUY`
        );
        return;
      }

      const buyPrice = roundToTick(nodeMin, filters.tickSize);
      let buyQty = floorToStep(BUY_AMOUNT_USD / buyPrice, filters.stepSize);
      if (buyQty < filters.minQty) buyQty = filters.minQty;
      if (!ensureNotional(buyPrice, buyQty, filters.minNotional)) {
        await sendTelegramMessage(
          `‚ö†Ô∏è B·ªè qua BUY: Notional kh√¥ng ƒë·∫°t minNotional\n` +
          `‚Ä¢ Gi√°: ${buyPrice}\n` +
          `‚Ä¢ SL: ${buyQty}\n` +
          `‚Ä¢ minNotional: ${filters.minNotional}`
        );
        return;
      }

      const buyOrder = await placeLimit('BUY', buyPrice, buyQty);
      state.mode = 'BUY_PLACED';
      state.buyOrderId = buyOrder.orderId;

      await sendTelegramMessage(
        `üü© ƒê·∫∂T BUY ${SYMBOL}\n` +
        `‚Ä¢ N·ªët: [${nodeMin}, ${nodeMax}]\n` +
        `‚Ä¢ ID: ${buyOrder.orderId}\n` +
        `‚Ä¢ Gi√°: ${buyOrder.price}\n` +
        `‚Ä¢ SL: ${buyOrder.origQty}`
      );
      return;
    }

    if (state.mode === 'BUY_PLACED' && state.buyOrderId) {
      // Ki·ªÉm tra kh·ªõp BUY
      const o = await retry(() => getOrder(state.buyOrderId), {retries: 3, delay: 400});
      if (o.status === 'FILLED') {
        const executedQty = toNumber(o.executedQty || 0);
        const cumQuote    = toNumber(o.cummulativeQuoteQty || 0);
        const avgBuyPrice = executedQty > 0 ? (cumQuote / executedQty) : null;

        state.lastBuyQty = executedQty;
        state.lastBuyAvg = avgBuyPrice;
        state.mode = 'HOLDING';

        await sendTelegramMessage(
          `‚úÖ BUY FILLED ${SYMBOL}\n` +
          `‚Ä¢ N·ªët: [${nodeMin}, ${nodeMax}]\n` +
          `‚Ä¢ ID: ${o.orderId}\n` +
          `‚Ä¢ SL kh·ªõp: ${executedQty}\n` +
          `‚Ä¢ Gi√° TB: ${avgBuyPrice ?? 'null'}`
        );
      } else if (['CANCELED','REJECTED','EXPIRED'].includes(o.status)) {
        state.mode = 'IDLE';
        state.buyOrderId = null;
        await sendTelegramMessage(`‚ö†Ô∏è BUY k·∫øt th√∫c ${o.status}, chuy·ªÉn v·ªÅ IDLE`);
      } else {
        // v·∫´n ch·ªù
        await sendTelegramMessage(
          `‚è≥ BUY ƒëang ch·ªù\n` +
          `‚Ä¢ ID: ${o.orderId}\n` +
          `‚Ä¢ Tr·∫°ng th√°i: ${o.status}\n` +
          `‚Ä¢ Gi√° hi·ªán t·∫°i: ${price}`
        );
      }
      return;
    }

    if (state.mode === 'HOLDING') {
      // Sau khi BUY kh·ªõp -> ƒë·∫∑t SELL ·ªü max n·ªët
      const sellPrice = formatByTick(ceilToTick(nodeMax, filters.tickSize), filters.tickSize);
      const sellQty   = floorToStep(state.lastBuyQty, filters.stepSize);

      if (sellQty < filters.minQty || !ensureNotional(sellPrice, sellQty, filters.minNotional)) {
        await sendTelegramMessage(`‚ö†Ô∏è B·ªè qua SELL: Kh√¥ng ƒë·∫°t qty/minNotional`);
        return;
      }

      const sellOrder = await placeLimit('SELL', sellPrice, sellQty);
      state.mode = 'SELL_PLACED';
      state.sellOrderId = sellOrder.orderId;

      await sendTelegramMessage(
        `üü• ƒê·∫∂T SELL ${SYMBOL}\n` +
        `‚Ä¢ N·ªët: [${nodeMin}, ${nodeMax}]\n` +
        `‚Ä¢ ID: ${sellOrder.orderId}\n` +
        `‚Ä¢ Gi√°: ${sellOrder.price}\n` +
        `‚Ä¢ SL: ${sellOrder.origQty}`
      );
      return;
    }

    if (state.mode === 'SELL_PLACED' && state.sellOrderId) {
      // Ki·ªÉm tra kh·ªõp SELL
      const o = await retry(() => getOrder(state.sellOrderId), {retries: 3, delay: 400});
      if (o.status === 'FILLED') {
        state.mode = 'IDLE';
        state.sellOrderId = null;
        state.buyOrderId  = null;
        state.lastBuyQty  = 0;
        state.lastBuyAvg  = null;

        await sendTelegramMessage(
          `üéâ SELL FILLED ${SYMBOL}\n` +
          `‚Ä¢ N·ªët: [${nodeMin}, ${nodeMax}]\n` +
          `‚Ä¢ ID: ${o.orderId}\n` +
          `‚Ä¢ SL kh·ªõp: ${o.executedQty}\n` +
          `‚Ä¢ Gi√° TB: ${toNumber(o.cummulativeQuoteQty)/toNumber(o.executedQty)}`
        );

        // Sau SELL kh·ªõp -> v√≤ng sau s·∫Ω IDLE v√† ki·ªÉm tra l·∫°i n·ªët ƒë·ªÉ ƒë·∫∑t BUY
      } else if (['CANCELED','REJECTED','EXPIRED'].includes(o.status)) {
        state.mode = 'HOLDING'; // v·∫´n c√≤n gi·ªØ coin?
        state.sellOrderId = null;
        await sendTelegramMessage(`‚ö†Ô∏è SELL k·∫øt th√∫c ${o.status}, quay l·∫°i tr·∫°ng th√°i HOLDING`);
      } else {
        await sendTelegramMessage(
          `‚è≥ SELL ƒëang ch·ªù\n` +
          `‚Ä¢ ID: ${o.orderId}\n` +
          `‚Ä¢ Tr·∫°ng th√°i: ${o.status}\n` +
          `‚Ä¢ Gi√° hi·ªán t·∫°i: ${price}`
        );
      }
      return;
    }

  } catch (err) {
    const msg = err.response?.data ? JSON.stringify(err.response.data) : err.message;
    console.error('‚ùå mainCycle l·ªói:', msg);
    await sendTelegramMessage(`‚ùå L·ªói: ${msg}`);
  }
}

// ====== Kh·ªüi ƒë·ªông & v√≤ng l·∫∑p ======
async function botLoop() {
  await mainCycle();
}

(async () => {
  await loadSymbolFilters();
  console.log('üöÄ Bot PAXG Grid b·∫Øt ƒë·∫ßu ch·∫°y‚Ä¶');
  await sendTelegramMessage('üöÄ Bot PAXG Grid ƒë√£ kh·ªüi ƒë·ªông v√† s·∫µn s√†ng giao d·ªãch');

  setInterval(botLoop, INTERVAL);
})();

// ====== HTTP server & keepalive ======
app.get('/health', (_, r) => r.json({ status: 'ok' }));
app.get('/',    (_, r) => r.send('Bot PAXG Grid ƒëang ch·∫°y‚Ä¶'));

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`üåê Server t·∫°i port ${PORT}`));

// keepalive
if (KEEPALIVE_URL) {
  setInterval(() => {
    axios.get(KEEPALIVE_URL).catch(()=>{/* ignore */});
  }, 14 * 60 * 1000);
}

// ====== Graceful shutdown ======
async function shutdown(sig) {
  try {
    await sendTelegramMessage(`üõë Bot d·ª´ng (${sig}) ‚Äî ƒëang tho√°t an to√†n`);
  } catch (_) {}
  process.exit(0);
}
['SIGINT','SIGTERM'].forEach(sig => process.on(sig, () => shutdown(sig)));
